@*
 * Copyright 2020 HM Revenue & Customs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *@

@import java.time.LocalDate
@import cats.syntax.order._

@import uk.gov.hmrc.cgtpropertydisposalsfrontend.models.finance.AmountInPence
@import uk.gov.hmrc.cgtpropertydisposalsfrontend.models.returns.ReturnSummary
@import uk.gov.hmrc.cgtpropertydisposalsfrontend.models.finance.ChargeWithPayments.ChargeWithPaymentsOps
@import uk.gov.hmrc.cgtpropertydisposalsfrontend.models.LocalDateUtils

@this(
sentReturnItem: uk.gov.hmrc.cgtpropertydisposalsfrontend.views.html.account.components.return_list_item,
sentReturnsHeader: uk.gov.hmrc.cgtpropertydisposalsfrontend.views.html.account.components.returns_list_header
)

@(sentReturns: List[ReturnSummary], totalLeftToPay: AmountInPence)(implicit messages:Messages)

@optionalDateOrdering = @{ (date1: Option[LocalDate], date2: Option[LocalDate]) =>
    (date1, date2) match {
        case (None, None) => false
        case (Some(_), None) => true
        case (None, Some(_)) => false
        case (Some(d1), Some(d2)) => d1.isAfter(d2)
    }

}

 @sentReturnsWithPaymentDueDate = @{
  sentReturns.map(    r =>
      r -> r.chargesWithPayments
           .filter(_.outstandingAmount() > AmountInPence.zero)
           .map(_.dueDate)
           .sortWith(LocalDateUtils.order.compare(_, _) < 0)
           .headOption
  )
 }

 @ordered = @{
   sentReturnsWithPaymentDueDate.sortWith{ case ((r1, d1), (r2, d2)) =>
       if(!d1.exists(d2.contains(_))) optionalDateOrdering(d1, d2)
       else if(!r1.lastUpdatedDate.exists(r2.lastUpdatedDate.contains(_))) optionalDateOrdering(r1.lastUpdatedDate, r2.lastUpdatedDate)
       else r1.submissionDate.isAfter(r2.submissionDate)

   }
 }


@sentReturnsHeader(totalLeftToPay)

<ul class="return-list">
  @ordered.map{ case (sentReturn, paymentDueDate) =>
    @sentReturnItem(sentReturn, paymentDueDate)
  }
</ul>

<p>@messages("returns.paymentTakes3Days")</p>
